import logging
from neo4j import GraphDatabase
from config import settings
import traceback

logger = logging.getLogger(__name__)

class GraphMemory:
    """
    Neo4j-based graph memory component for T1 Brain system.
    Manages graph-based storage of queries, responses, and associated metadata (intent, topic, emotion).
    """
    def __init__(self):
        """
        Initialize Neo4j connection and verify connectivity.
        Uses connection parameters from settings module.
        """
        try:
            # Establish connection to Neo4j database
            self.driver = GraphDatabase.driver(
                settings.NEO4J_URL,
                auth=(settings.NEO4J_USER, settings.NEO4J_PASSWORD),
                encrypted=False
            )
            # Verify connection on initialization
            if self.verify_connection():
                logger.info("✅ Connected to Neo4j.")
            else:
                logger.warning("⚠️ Connected to Neo4j but verification failed.")
        except Exception as e:
            logger.error(f"❌ Neo4j connection failed: {e}")
            logger.error(traceback.format_exc())
            # Don't raise here to prevent breaking the application if Neo4j is down
            self.driver = None

    def close(self):
        """
        Close Neo4j connection when done.
        """
        if self.driver:
            self.driver.close()

    def verify_connection(self):
        """
        Verify that the Neo4j connection is working properly by running a simple query.
        
        Returns:
            bool: True if connection is valid, False otherwise
        """
        try:
            if not self.driver:
                logger.error("❌ Neo4j driver is not initialized")
                return False
                
            with self.driver.session() as session:
                result = session.run("RETURN 1 AS num")
                record = result.single()
                return record and record["num"] == 1
        except Exception as e:
            logger.error(f"❌ Neo4j connection verification failed: {e}")
            logger.error(traceback.format_exc())
            return False

    def store_graph_memory(self, query, response, session_id, metadata=None):
        """
        Store detailed memory context in Neo4j including relationships to sentiment, topics, intent, etc.
        
        Args:
            query (str): User query text
            response (str): System response text
            session_id (str): Unique session identifier
            metadata (dict): Optional metadata dictionary with keys like 'intent', 'topic', 'sentiment'/'emotion'
            
        Returns:
            bool: True if operation succeeded, False otherwise
        """
        if not self.driver:
            logger.error("❌ Cannot store graph memory: Neo4j driver is not initialized")
            return False
            
        try:
            # Log the input parameters for debugging
            logger.debug(f"store_graph_memory: query={query[:30]}..., session_id={session_id}, metadata={metadata}")
            
            # Use query_text to avoid parameter name collision
            query_text = query
            
            with self.driver.session() as session:
                # Create query and response nodes with relationship
                with session.begin_transaction() as tx:
                    tx.run(
                        """
                        MERGE (q:Query {text: $query_text, session_id: $session_id, project: 't1brain'})
                        MERGE (r:Response {text: $response, project: 't1brain'})
                        MERGE (q)-[:REPLIED_WITH]->(r)
                        """,
                        query_text=query_text,
                        response=response,
                        session_id=session_id
                    )

                # Process metadata if provided
                if metadata:
                    # Add intent if present
                    if "intent" in metadata:
                        with session.begin_transaction() as tx:
                            tx.run(
                                """
                                MERGE (i:Intent {type: $intent, project: 't1brain'})
                                MERGE (q:Query {text: $query_text, session_id: $session_id, project: 't1brain'})
                                MERGE (q)-[:HAS_INTENT]->(i)
                                """,
                                intent=metadata["intent"],
                                query_text=query_text,
                                session_id=session_id
                            )
                    
                    # Add topic if present
                    if "topic" in metadata:
                        with session.begin_transaction() as tx:
                            tx.run(
                                """
                                MERGE (t:Topic {label: $topic, project: 't1brain'})
                                MERGE (q:Query {text: $query_text, session_id: $session_id, project: 't1brain'})
                                MERGE (q)-[:HAS_TOPIC]->(t)
                                """,
                                topic=metadata["topic"],
                                query_text=query_text,
                                session_id=session_id
                            )
                    
                    # Handle both sentiment and emotion consistently
                    if "sentiment" in metadata or "emotion" in metadata:
                        emotion_value = metadata.get("emotion") or metadata.get("sentiment")
                        with session.begin_transaction() as tx:
                            tx.run(
                                """
                                MERGE (e:Emotion {name: $emotion, project: 't1brain'})
                                MERGE (q:Query {text: $query_text, session_id: $session_id, project: 't1brain'})
                                MERGE (q)-[:EXPRESSES]->(e)
                                """,
                                emotion=emotion_value,
                                query_text=query_text,
                                session_id=session_id
                            )
            
            # Verify nodes were created and log relationship counts
            with self.driver.session() as verify_session:
                # Verify Query node exists
                result = verify_session.run(
                    "MATCH (q:Query {text: $query_text, session_id: $session_id, project: 't1brain'}) RETURN count(q) as count",
                    query_text=query_text,
                    session_id=session_id
                )
                record = result.single()
                if record and record["count"] > 0:
                    logger.info(f"✅ Verified Query node created in store_graph_memory: {record['count']} nodes found")
                else:
                    logger.warning(f"⚠️ Query node not found after creation attempt in store_graph_memory")
                
                # Log relationship counts if metadata was provided
                if metadata:
                    # Check intent relationships
                    if "intent" in metadata:
                        intent_result = verify_session.run(
                            """
                            MATCH (q:Query {text: $query_text, session_id: $session_id, project: 't1brain'})-[:HAS_INTENT]->(:Intent) 
                            RETURN count(*) as count
                            """,
                            query_text=query_text,
                            session_id=session_id
                        )
                        intent_record = intent_result.single()
                        logger.info(f"Intent relationships: {intent_record['count'] if intent_record else 0}")
                    
                    # Check topic relationships
                    if "topic" in metadata:
                        topic_result = verify_session.run(
                            """
                            MATCH (q:Query {text: $query_text, session_id: $session_id, project: 't1brain'})-[:HAS_TOPIC]->(:Topic) 
                            RETURN count(*) as count
                            """,
                            query_text=query_text,
                            session_id=session_id
                        )
                        topic_record = topic_result.single()
                        logger.info(f"Topic relationships: {topic_record['count'] if topic_record else 0}")
                    
                    # Check emotion relationships
                    if "sentiment" in metadata or "emotion" in metadata:
                        emotion_result = verify_session.run(
                            """
                            MATCH (q:Query {text: $query_text, session_id: $session_id, project: 't1brain'})-[:EXPRESSES]->(:Emotion) 
                            RETURN count(*) as count
                            """,
                            query_text=query_text,
                            session_id=session_id
                        )
                        emotion_record = emotion_result.single()
                        logger.info(f"Emotion relationships: {emotion_record['count'] if emotion_record else 0}")
                    
            return True
        except Exception as e:
            logger.error(f"❌ Error storing graph memory: {type(e).__name__}: {e}")
            logger.error(traceback.format_exc())
            return False

    def summarize_session(self, session_id):
        """
        Summarize session by extracting intent/topic/emotion relationships.
        
        Args:
            session_id (str): Unique session identifier
            
        Returns:
            list: List of dictionaries containing query and associated metadata
        """
        if not self.driver:
            logger.error("❌ Cannot summarize session: Neo4j driver is not initialized")
            return []
            
        try:
            with self.driver.session() as session:
                result = session.run(
                    """
                    MATCH (q:Query {session_id: $session_id, project: 't1brain'})
                    OPTIONAL MATCH (q)-[:HAS_INTENT]->(i:Intent)
                    OPTIONAL MATCH (q)-[:HAS_TOPIC]->(t:Topic)
                    OPTIONAL MATCH (q)-[:EXPRESSES]->(e:Emotion)
                    RETURN q.text AS query, COLLECT(DISTINCT i.type) AS intents,
                           COLLECT(DISTINCT t.label) AS topics,
                           COLLECT(DISTINCT e.name) AS emotions
                    """,
                    session_id=session_id
                )
                return [record.data() for record in result]
        except Exception as e:
            logger.error(f"❌ Error summarizing session: {type(e).__name__}: {e}")
            logger.error(traceback.format_exc())
            return []

    def add_context_nodes(self, query, intent=None, topic=None, emotion=None):
        """
        Lightweight enrichment method called from session_memory.py
        Adds minimal context links for intent, topic, and emotion.
        
        Args:
            query (str): User query text
            intent (str, optional): Intent classification
            topic (str, optional): Topic classification
            emotion (str, optional): Emotion/sentiment classification
            
        Returns:
            bool: True if operation succeeded, False otherwise
        """
        if not self.driver:
            logger.error("❌ Cannot add context nodes: Neo4j driver is not initialized")
            return False
            
        if not query:
            logger.error("❌ Cannot add context nodes: query is required")
            return False
            
        logger.info(f"🚀 Enriching Query: {query[:50]} | intent={intent}, topic={topic}, emotion={emotion}")
        
        # Check if any metadata is provided
        if not any([intent, topic, emotion]):
            logger.info("ℹ️ No metadata provided for enrichment, skipping")
            return True
        
        # Use query_text to avoid parameter name collision
        query_text = query
            
        try:
            with self.driver.session() as session:
                # Create Query node with project label
                with session.begin_transaction() as tx:
                    tx.run(
                        "MERGE (q:Query {text: $query_text, project: 't1brain'})",
                        query_text=query_text
                    )
                
                # Add Intent if provided
                if intent:
                    with session.begin_transaction() as tx:
                        tx.run("""
                            MATCH (q:Query {text: $query_text, project: 't1brain'})
                            MERGE (i:Intent {type: $intent, project: 't1brain'})
                            MERGE (q)-[:HAS_INTENT]->(i)
                        """, query_text=query_text, intent=intent)
                
                # Add Topic if provided
                if topic:
                    with session.begin_transaction() as tx:
                        tx.run("""
                            MATCH (q:Query {text: $query_text, project: 't1brain'})
                            MERGE (t:Topic {label: $topic, project: 't1brain'})
                            MERGE (q)-[:HAS_TOPIC]->(t)
                        """, query_text=query_text, topic=topic)
                
                # Add Emotion if provided
                if emotion:
                    with session.begin_transaction() as tx:
                        tx.run("""
                            MATCH (q:Query {text: $query_text, project: 't1brain'})
                            MERGE (e:Emotion {name: $emotion, project: 't1brain'})
                            MERGE (q)-[:EXPRESSES]->(e)
                        """, query_text=query_text, emotion=emotion)
            
            # Verify nodes and relationships in a separate session
            with self.driver.session() as verify_session:
                # Verify Query node exists
                result = verify_session.run(
                    "MATCH (q:Query {text: $query_text, project: 't1brain'}) RETURN count(q) as count",
                    query_text=query_text
                )
                record = result.single()
                if record and record["count"] > 0:
                    logger.info(f"✅ Verified Query node created: {record['count']} nodes found")
                    
                    # Log relationship counts
                    if intent:
                        intent_result = verify_session.run(
                            "MATCH (q:Query {text: $query_text, project: 't1brain'})-[:HAS_INTENT]->(:Intent) RETURN count(*) as count",
                            query_text=query_text
                        )
                        intent_record = intent_result.single()
                        logger.info(f"Intent relationships: {intent_record['count'] if intent_record else 0}")
                    
                    if topic:
                        topic_result = verify_session.run(
                            "MATCH (q:Query {text: $query_text, project: 't1brain'})-[:HAS_TOPIC]->(:Topic) RETURN count(*) as count",
                            query_text=query_text
                        )
                        topic_record = topic_result.single()
                        logger.info(f"Topic relationships: {topic_record['count'] if topic_record else 0}")
                    
                    if emotion:
                        emotion_result = verify_session.run(
                            "MATCH (q:Query {text: $query_text, project: 't1brain'})-[:EXPRESSES]->(:Emotion) RETURN count(*) as count",
                            query_text=query_text
                        )
                        emotion_record = emotion_result.single()
                        logger.info(f"Emotion relationships: {emotion_record['count'] if emotion_record else 0}")
                else:
                    logger.warning(f"⚠️ Query node not found after creation attempt")
            
            return True
        except Exception as e:
            logger.error(f"❌ Error in add_context_nodes(): {type(e).__name__}: {e}")
            logger.error(f"Parameters: query={query}, intent={intent}, topic={topic}, emotion={emotion}")
            logger.error(f"Traceback: {traceback.format_exc()}")
            return False
            
    def debug_enrichment(self, query, metadata=None):
        """
        Debug method to test enrichment functionality directly.
        Can be used independently for CLI testing.
        
        Args:
            query (str): User query text
            metadata (dict): Optional metadata dictionary with keys like 'intent', 'topic', 'sentiment'/'emotion'
            
        Returns:
            bool: True if operation succeeded, False otherwise
        """
        logger.info(f"🔍 Debug enrichment for query: {query[:50]}")
        logger.info(f"Metadata: {metadata}")
        
        if not metadata:
            logger.warning("No metadata provided for debug enrichment")
            return False
            
        intent = metadata.get("intent")
        topic = metadata.get("topic")
        emotion = metadata.get("emotion") or metadata.get("sentiment")
        
        result = self.add_context_nodes(query, intent, topic, emotion)
        logger.info(f"Debug enrichment result: {result}")
        return result

# CLI test function for standalone module testing
def main():
    """
    Standalone CLI test entry point for GraphMemory.
    Run this module directly to test Neo4j connection and graph operations.
    """
    import sys
    import argparse
    
    # Configure logging for CLI usage
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s [%(levelname)s] %(message)s',
        handlers=[logging.StreamHandler()]
    )
    
    parser = argparse.ArgumentParser(description="T1 Brain Graph Memory Test Tool")
    parser.add_argument("--query", "-q", required=True, help="Test query text")
    parser.add_argument("--intent", "-i", help="Intent classification")
    parser.add_argument("--topic", "-t", help="Topic classification")
    parser.add_argument("--emotion", "-e", help="Emotion classification")
    
    args = parser.parse_args()
    
    # Create metadata dictionary from arguments
    metadata = {}
    if args.intent:
        metadata["intent"] = args.intent
    if args.topic:
        metadata["topic"] = args.topic
    if args.emotion:
        metadata["emotion"] = args.emotion
        
    # Test GraphMemory
    logger.info("Initializing GraphMemory...")
    memory = GraphMemory()
    
    if not memory.verify_connection():
        logger.error("Failed to connect to Neo4j. Check your settings and Neo4j status.")
        return 1
        
    logger.info("Running debug enrichment...")
    result = memory.debug_enrichment(args.query, metadata)
    
    if result:
        logger.info("✅ Debug enrichment completed successfully")
    else:
        logger.error("❌ Debug enrichment failed")
        
    # Clean up
    memory.close()
    return 0 if result else 1

if __name__ == "__main__":
    sys.exit(main())