import sys
import logging
import redis
import psycopg2
from fastapi import FastAPI, Depends, HTTPException, Header, Request
from pydantic import BaseModel
from typing import Optional, Dict

# Ensure Python can locate settings.py
sys.path.append("/root/t1-brain/config")
from settings import PG_HOST, PG_DATABASE, PG_USER, PG_PASSWORD

# Ensure Python can locate session_memory.py
sys.path.append("/root/t1-brain/memory")
from session_memory import HybridSessionMemory

# ‚úÖ Setup Logging (API Request Monitoring)
logging.basicConfig(
    filename="/root/t1-brain/logs/api_requests.log",
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    force=True  # ‚úÖ Ensure existing log handlers are replaced
)

# ‚úÖ Initialize FastAPI
app = FastAPI()

# ‚úÖ Initialize Hybrid Memory Handler
memory_handler = HybridSessionMemory()

# ‚úÖ Initialize Redis Connection
try:
    redis_client = redis.StrictRedis(host="localhost", port=6379, decode_responses=True)
    logging.info("‚úÖ Redis connection established.")
except Exception as e:
    logging.error(f"‚ùå Redis connection failed: {str(e)}")
    raise

# ‚úÖ API Key Authentication Function
def verify_api_key(request: Request):
    """Validate API Key from headers"""
    api_key = request.headers.get("X-API-KEY") or request.headers.get("x-api-key")

    if not api_key:
        logging.warning("‚ö† API Key missing in request headers.")
        raise HTTPException(status_code=401, detail="API Key missing")

    logging.info(f"üîë API Key Verified: {api_key}")
    return api_key

# ‚úÖ API Middleware for Logging Requests
@app.middleware("http")
async def log_requests(request: Request, call_next):
    """Log incoming API requests for security monitoring."""
    client_ip = request.client.host
    request_info = f"üîç API Request - IP: {client_ip}, Path: {request.url.path}, Method: {request.method}"
    
    logging.info(request_info)  # ‚úÖ Log the request
    
    response = await call_next(request)
    return response

# ‚úÖ Memory API Endpoints - Secured with API Key Authentication
class MemoryRequest(BaseModel):
    session_id: str
    query: str
    response: Optional[str] = None
    memory_type: Optional[str] = "semantic"
    sentiment: Optional[str] = "neutral"

class MemoryRetrieveRequest(BaseModel):
    session_id: str
    query: str
    filters: Optional[Dict] = {}

class MemoryDeleteRequest(BaseModel):
    session_id: str
    query: str

@app.post("/memory/store")
async def api_store_memory(request: MemoryRequest, api_key: str = Depends(verify_api_key)):
    """Store memory securely."""
    return memory_handler.store_memory(request.session_id, request.query, request.response, request.memory_type, request.sentiment)

@app.post("/memory/retrieve")
async def api_retrieve_memory(request: MemoryRetrieveRequest, api_key: str = Depends(verify_api_key)):
    """Retrieve stored memory."""
    memory = memory_handler.retrieve_memory(request.session_id, request.query, request.filters)
    return {"status": "retrieved", "memory": memory} if memory else {"status": "not_found"}

@app.post("/memory/update")
async def api_update_memory(request: MemoryRequest, api_key: str = Depends(verify_api_key)):
    """Update existing memory without duplication."""
    return memory_handler.update_memory(request.session_id, request.query, request.response, request.memory_type, request.sentiment)

@app.get("/memory/topics")
async def api_list_memory_topics(session_id: str, api_key: str = Depends(verify_api_key)):
    """List memory topics for a session."""
    topics = memory_handler.list_topics(session_id)
    return {"status": "retrieved", "topics": topics} if topics else {"status": "not_found"}

@app.post("/memory/session")
async def api_manage_session(api_key: str = Depends(verify_api_key)):
    """Manage session rehydration and expiration."""
    return memory_handler.session_management(api_key)

@app.delete("/memory/delete")
async def api_delete_memory(request: MemoryDeleteRequest, api_key: str = Depends(verify_api_key)):
    """Delete stored memory."""
    return memory_handler.delete_memory(request.session_id, request.query)

# ‚úÖ Health Check API
@app.get("/health")
async def health_check():
    """Check API health status."""
    redis_status = "‚úÖ Redis Connected" if redis_client.ping() else "‚ùå Redis Not Connected"
    try:
        conn = psycopg2.connect(host=PG_HOST, database=PG_DATABASE, user=PG_USER, password=PG_PASSWORD)
        conn.close()
        db_status = "‚úÖ PostgreSQL Connected"
    except:
        db_status = "‚ùå PostgreSQL Not Connected"
    return {"redis": redis_status, "database": db_status}

# ‚úÖ Monitor Redis Sessions
@app.get("/monitor/sessions")
def monitor_sessions():
    """Monitor active Redis sessions."""
    try:
        sessions = list(redis_client.keys("session:*"))
        return {"active_sessions": sessions}
    except Exception as e:
        logging.error(f"‚ùå Error retrieving active sessions: {e}")
        return {"error": "Could not retrieve session data"}

# ‚úÖ Optimize PostgreSQL Query Performance
@app.get("/optimize/postgres")
def optimize_postgresql_queries():
    """Optimize PostgreSQL queries by adding indexes."""
    memory_handler.connect_to_db()
    try:
        memory_handler.pg_cursor.execute("CREATE INDEX IF NOT EXISTS idx_embeddings_session_id ON embeddings(session_id);")
        memory_handler.pg_cursor.execute("CREATE INDEX IF NOT EXISTS idx_embeddings_query ON embeddings(query);")
        memory_handler.pg_conn.commit()
        logging.info("‚úÖ PostgreSQL indexes optimized for faster retrieval.")
        return {"status": "success", "message": "PostgreSQL indexes created successfully."}
    except Exception as e:
        logging.error(f"‚ùå PostgreSQL Optimization Error: {e}")
        return {"status": "error", "message": "Database optimization failed."}

@app.get("/secure-endpoint")
def secure_route(api_key: str = Depends(verify_api_key)):
    """Test API Key authentication"""
    return {"message": "You have access to this endpoint!"}
